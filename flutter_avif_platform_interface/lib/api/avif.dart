// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `_dispose_decoder`, `_get_next_frame`, `_reset_decoder`
// These types are ignored because they are not used by any `pub` functions: `CodecResponse`, `DECODERS`, `DecoderCommand`, `Decoder`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `deref`, `initialize`

Future<Frame> decodeSingleFrameImage({required List<int> avifBytes}) =>
    FlutterAvif.instance.api
        .crateApiAvifDecodeSingleFrameImage(avifBytes: avifBytes);

Future<AvifInfo> initMemoryDecoder(
        {required String key, required List<int> avifBytes}) =>
    FlutterAvif.instance.api
        .crateApiAvifInitMemoryDecoder(key: key, avifBytes: avifBytes);

Future<bool> resetDecoder({required String key}) =>
    FlutterAvif.instance.api.crateApiAvifResetDecoder(key: key);

Future<bool> disposeDecoder({required String key}) =>
    FlutterAvif.instance.api.crateApiAvifDisposeDecoder(key: key);

Future<Frame> getNextFrame({required String key}) =>
    FlutterAvif.instance.api.crateApiAvifGetNextFrame(key: key);

Future<Uint8List> encodeAvif(
        {required int width,
        required int height,
        required int speed,
        required int maxThreads,
        required BigInt timescale,
        required int maxQuantizer,
        required int minQuantizer,
        required int maxQuantizerAlpha,
        required int minQuantizerAlpha,
        required List<EncodeFrame> imageSequence,
        required List<int> exifData}) =>
    FlutterAvif.instance.api.crateApiAvifEncodeAvif(
        width: width,
        height: height,
        speed: speed,
        maxThreads: maxThreads,
        timescale: timescale,
        maxQuantizer: maxQuantizer,
        minQuantizer: minQuantizer,
        maxQuantizerAlpha: maxQuantizerAlpha,
        minQuantizerAlpha: minQuantizerAlpha,
        imageSequence: imageSequence,
        exifData: exifData);

class AvifInfo {
  final int width;
  final int height;
  final int imageCount;
  final double duration;

  const AvifInfo({
    required this.width,
    required this.height,
    required this.imageCount,
    required this.duration,
  });

  @override
  int get hashCode =>
      width.hashCode ^
      height.hashCode ^
      imageCount.hashCode ^
      duration.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AvifInfo &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          imageCount == other.imageCount &&
          duration == other.duration;
}

class EncodeFrame {
  final Uint8List data;
  final BigInt durationInTimescale;

  const EncodeFrame({
    required this.data,
    required this.durationInTimescale,
  });

  @override
  int get hashCode => data.hashCode ^ durationInTimescale.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EncodeFrame &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          durationInTimescale == other.durationInTimescale;
}

class Frame {
  final Uint8List data;
  final double duration;
  final int width;
  final int height;

  const Frame({
    required this.data,
    required this.duration,
    required this.width,
    required this.height,
  });

  @override
  int get hashCode =>
      data.hashCode ^ duration.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Frame &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          duration == other.duration &&
          width == other.width &&
          height == other.height;
}
